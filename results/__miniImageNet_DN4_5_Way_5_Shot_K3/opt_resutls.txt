Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar' (epoch 14)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar' (epoch 14)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar' (epoch 14)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar' (epoch 14)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar' (epoch 14)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar' (epoch 14)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar' (epoch 14)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar' (epoch 14)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar' (epoch 14)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar' (epoch 14)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar' (epoch 14)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar' (epoch 14)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar' (epoch 14)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_1Shot_K3/model_best.pth.tar' (epoch 14)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Test-(0): [100/600]	Time 0.156 (0.156)	Loss 5.243 (8.121)	Prec@1 50.000 (38.713)
Test-(0): [200/600]	Time 0.137 (0.149)	Loss 9.433 (8.017)	Prec@1 34.000 (39.234)
Test-(0): [300/600]	Time 0.135 (0.148)	Loss 7.491 (8.113)	Prec@1 52.000 (39.090)
Test-(0): [400/600]	Time 0.132 (0.147)	Loss 13.231 (8.156)	Prec@1 16.000 (39.327)
Test-(0): [500/600]	Time 0.129 (0.146)	Loss 10.032 (8.105)	Prec@1 48.000 (39.645)
 * Prec@1 39.767 Best_prec1 0.000
============ Testing on the test set ============
Test-(0): [100/600]	Time 0.142 (0.157)	Loss 12.472 (9.064)	Prec@1 38.000 (36.495)
Test-(0): [200/600]	Time 0.124 (0.151)	Loss 7.056 (9.215)	Prec@1 38.000 (36.657)
Test-(0): [300/600]	Time 0.128 (0.150)	Loss 13.378 (9.060)	Prec@1 32.000 (36.691)
Test-(0): [400/600]	Time 0.150 (0.149)	Loss 9.945 (8.999)	Prec@1 34.000 (36.459)
Test-(0): [500/600]	Time 0.134 (0.148)	Loss 10.596 (8.997)	Prec@1 28.000 (36.898)
 * Prec@1 36.943 Best_prec1 0.000
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Test-(0): [100/600]	Time 0.122 (0.164)	Loss 5.849 (7.378)	Prec@1 38.000 (40.079)
Test-(0): [200/600]	Time 0.149 (0.154)	Loss 11.851 (7.535)	Prec@1 48.000 (40.468)
Test-(0): [300/600]	Time 0.126 (0.152)	Loss 8.488 (7.630)	Prec@1 32.000 (39.993)
Test-(0): [400/600]	Time 0.161 (0.150)	Loss 6.919 (7.735)	Prec@1 34.000 (39.651)
Test-(0): [500/600]	Time 0.150 (0.151)	Loss 5.575 (7.591)	Prec@1 56.000 (39.880)
 * Prec@1 39.760 Best_prec1 0.000
============ Testing on the test set ============
Test-(0): [100/600]	Time 0.128 (0.159)	Loss 6.011 (7.807)	Prec@1 38.000 (40.574)
Test-(0): [200/600]	Time 0.124 (0.151)	Loss 6.048 (8.079)	Prec@1 38.000 (38.856)
Test-(0): [300/600]	Time 0.146 (0.150)	Loss 6.152 (8.086)	Prec@1 26.000 (38.551)
Test-(0): [400/600]	Time 0.131 (0.150)	Loss 5.867 (8.046)	Prec@1 46.000 (38.589)
Test-(0): [500/600]	Time 0.123 (0.149)	Loss 7.507 (8.090)	Prec@1 44.000 (38.711)
 * Prec@1 38.943 Best_prec1 0.000
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Test-(16): [100/600]	Time 0.098 (0.128)	Loss 10.633 (8.120)	Prec@1 36.000 (38.337)
Test-(16): [200/600]	Time 0.114 (0.125)	Loss 9.374 (7.782)	Prec@1 30.000 (38.000)
Test-(16): [300/600]	Time 0.119 (0.123)	Loss 9.498 (7.922)	Prec@1 40.000 (37.681)
Test-(16): [400/600]	Time 0.109 (0.120)	Loss 5.997 (7.901)	Prec@1 44.000 (38.040)
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Test-(16): [100/600]	Time 0.096 (0.127)	Loss 4.195 (7.627)	Prec@1 58.000 (39.861)
Test-(16): [200/600]	Time 0.130 (0.121)	Loss 9.955 (7.772)	Prec@1 34.000 (39.761)
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Test-(0): [100/600]	Time 0.132 (0.152)	Loss 0.737 (0.835)	Prec@1 72.000 (68.059)
Test-(0): [200/600]	Time 0.141 (0.146)	Loss 0.599 (0.834)	Prec@1 74.000 (67.811)
Test-(0): [300/600]	Time 0.139 (0.144)	Loss 0.726 (0.830)	Prec@1 66.000 (67.907)
Test-(0): [400/600]	Time 0.137 (0.143)	Loss 0.815 (0.827)	Prec@1 74.000 (68.155)
Test-(0): [500/600]	Time 0.179 (0.142)	Loss 0.577 (0.832)	Prec@1 80.000 (67.836)
 * Prec@1 67.780 Best_prec1 0.000
============ Testing on the test set ============
Test-(0): [100/600]	Time 0.123 (0.151)	Loss 0.553 (0.756)	Prec@1 72.000 (71.168)
Test-(0): [200/600]	Time 0.142 (0.148)	Loss 1.047 (0.778)	Prec@1 66.000 (70.697)
Test-(0): [300/600]	Time 0.138 (0.146)	Loss 0.607 (0.782)	Prec@1 78.000 (70.631)
Test-(0): [400/600]	Time 0.125 (0.144)	Loss 1.271 (0.785)	Prec@1 60.000 (70.534)
Test-(0): [500/600]	Time 0.136 (0.143)	Loss 1.064 (0.783)	Prec@1 58.000 (70.603)
 * Prec@1 70.803 Best_prec1 0.000
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Test-(0): [100/600]	Time 0.115 (0.129)	Loss 1.245 (1.216)	Prec@1 66.000 (68.871)
Test-(0): [200/600]	Time 0.127 (0.123)	Loss 1.245 (1.218)	Prec@1 66.000 (68.726)
Test-(0): [300/600]	Time 0.127 (0.121)	Loss 1.205 (1.213)	Prec@1 70.000 (69.136)
Test-(0): [400/600]	Time 0.107 (0.119)	Loss 1.305 (1.217)	Prec@1 60.000 (68.743)
Test-(0): [500/600]	Time 0.102 (0.119)	Loss 1.025 (1.218)	Prec@1 88.000 (68.727)
 * Prec@1 68.693 Best_prec1 0.000
============ Testing on the test set ============
Test-(0): [100/600]	Time 0.112 (0.129)	Loss 1.145 (1.185)	Prec@1 76.000 (72.000)
Test-(0): [200/600]	Time 0.119 (0.122)	Loss 1.165 (1.188)	Prec@1 74.000 (71.642)
Test-(0): [300/600]	Time 0.125 (0.119)	Loss 1.225 (1.190)	Prec@1 68.000 (71.502)
Test-(0): [400/600]	Time 0.112 (0.118)	Loss 1.185 (1.192)	Prec@1 72.000 (71.327)
Test-(0): [500/600]	Time 0.127 (0.118)	Loss 1.265 (1.193)	Prec@1 64.000 (71.210)
 * Prec@1 71.233 Best_prec1 0.000
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Test-(0): [100/600]	Time 0.125 (0.138)	Loss 1.325 (1.232)	Prec@1 58.000 (67.267)
Test-(0): [200/600]	Time 0.133 (0.133)	Loss 1.185 (1.221)	Prec@1 72.000 (68.418)
Test-(0): [300/600]	Time 0.121 (0.131)	Loss 1.305 (1.220)	Prec@1 60.000 (68.492)
Test-(0): [400/600]	Time 0.145 (0.130)	Loss 1.245 (1.225)	Prec@1 66.000 (67.960)
Test-(0): [500/600]	Time 0.145 (0.130)	Loss 1.405 (1.224)	Prec@1 50.000 (68.040)
 * Prec@1 68.223 Best_prec1 0.000
============ Testing on the test set ============
Test-(0): [100/600]	Time 0.120 (0.140)	Loss 1.285 (1.199)	Prec@1 62.000 (70.535)
Test-(0): [200/600]	Time 0.117 (0.135)	Loss 1.245 (1.198)	Prec@1 66.000 (70.647)
Test-(0): [300/600]	Time 0.114 (0.132)	Loss 1.265 (1.196)	Prec@1 64.000 (70.897)
Test-(0): [400/600]	Time 0.151 (0.132)	Loss 1.245 (1.197)	Prec@1 66.000 (70.763)
Test-(0): [500/600]	Time 0.126 (0.132)	Loss 1.165 (1.198)	Prec@1 74.000 (70.671)
 * Prec@1 70.730 Best_prec1 0.000
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): XGBHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Test-(0): [100/600]	Time 0.360 (0.144)	Loss 0.689 (0.820)	Prec@1 70.000 (68.396)
Test-(0): [200/600]	Time 0.120 (0.136)	Loss 0.835 (0.808)	Prec@1 68.000 (69.055)
Test-(0): [300/600]	Time 0.138 (0.134)	Loss 0.437 (0.821)	Prec@1 86.000 (68.399)
Test-(0): [400/600]	Time 0.146 (0.133)	Loss 1.307 (0.823)	Prec@1 50.000 (68.464)
Test-(0): [500/600]	Time 0.140 (0.132)	Loss 1.055 (0.821)	Prec@1 60.000 (68.571)
 * Prec@1 68.513 Best_prec1 0.000
============ Testing on the test set ============
Test-(0): [100/600]	Time 0.112 (0.135)	Loss 0.831 (0.790)	Prec@1 72.000 (69.703)
Test-(0): [200/600]	Time 0.107 (0.129)	Loss 0.619 (0.772)	Prec@1 78.000 (70.726)
Test-(0): [300/600]	Time 0.124 (0.128)	Loss 0.699 (0.770)	Prec@1 70.000 (70.605)
Test-(0): [400/600]	Time 0.119 (0.127)	Loss 0.543 (0.772)	Prec@1 78.000 (70.633)
Test-(0): [500/600]	Time 0.109 (0.127)	Loss 1.056 (0.774)	Prec@1 60.000 (70.623)
 * Prec@1 70.523 Best_prec1 0.000
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): RandomForestHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): RandomForestHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Test-(0): [100/600]	Time 0.127 (0.148)	Loss 1.037 (0.836)	Prec@1 60.000 (68.396)
Test-(0): [200/600]	Time 0.144 (0.143)	Loss 0.742 (0.835)	Prec@1 68.000 (68.587)
Test-(0): [300/600]	Time 0.114 (0.142)	Loss 1.263 (0.833)	Prec@1 56.000 (68.133)
Test-(0): [400/600]	Time 0.128 (0.139)	Loss 1.083 (0.834)	Prec@1 62.000 (68.020)
Test-(0): [500/600]	Time 0.144 (0.139)	Loss 0.644 (0.831)	Prec@1 72.000 (68.084)
 * Prec@1 68.377 Best_prec1 0.000
============ Testing on the test set ============
Test-(0): [100/600]	Time 0.125 (0.141)	Loss 1.028 (0.795)	Prec@1 62.000 (70.119)
Test-(0): [200/600]	Time 0.153 (0.137)	Loss 0.572 (0.775)	Prec@1 80.000 (70.667)
Test-(0): [300/600]	Time 0.134 (0.136)	Loss 0.775 (0.768)	Prec@1 66.000 (70.890)
Test-(0): [400/600]	Time 0.166 (0.135)	Loss 0.881 (0.775)	Prec@1 78.000 (70.594)
Test-(0): [500/600]	Time 0.131 (0.135)	Loss 1.146 (0.772)	Prec@1 62.000 (70.846)
 * Prec@1 70.660 Best_prec1 0.000
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): RandomForestHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 600
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): RandomForestHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 1000
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): RandomForestHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 1000
Test-(0): [100/600]	Time 0.130 (0.146)	Loss 0.992 (0.856)	Prec@1 62.000 (66.673)
Test-(0): [200/600]	Time 0.118 (0.140)	Loss 0.814 (0.842)	Prec@1 70.000 (67.602)
Test-(0): [300/600]	Time 0.130 (0.138)	Loss 0.707 (0.831)	Prec@1 72.000 (67.967)
Test-(0): [400/600]	Time 0.122 (0.137)	Loss 0.615 (0.841)	Prec@1 80.000 (67.641)
Test-(0): [500/600]	Time 0.135 (0.137)	Loss 1.185 (0.842)	Prec@1 46.000 (67.625)
 * Prec@1 67.763 Best_prec1 0.000
============ Testing on the test set ============
Test-(0): [100/1000]	Time 0.139 (0.146)	Loss 0.707 (0.786)	Prec@1 70.000 (69.822)
Test-(0): [200/1000]	Time 0.118 (0.140)	Loss 0.831 (0.779)	Prec@1 66.000 (70.438)
Test-(0): [300/1000]	Time 0.125 (0.138)	Loss 0.667 (0.777)	Prec@1 74.000 (70.551)
Test-(0): [400/1000]	Time 0.163 (0.137)	Loss 0.543 (0.776)	Prec@1 76.000 (70.748)
Test-(0): [500/1000]	Time 0.113 (0.136)	Loss 0.756 (0.777)	Prec@1 64.000 (70.731)
Test-(0): [600/1000]	Time 0.116 (0.136)	Loss 0.497 (0.781)	Prec@1 76.000 (70.562)
Test-(0): [700/1000]	Time 0.141 (0.135)	Loss 1.035 (0.785)	Prec@1 62.000 (70.402)
Test-(0): [800/1000]	Time 0.119 (0.135)	Loss 0.979 (0.784)	Prec@1 60.000 (70.387)
Test-(0): [900/1000]	Time 0.159 (0.135)	Loss 0.738 (0.787)	Prec@1 70.000 (70.257)
 * Prec@1 70.406 Best_prec1 0.000
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): RandomForestHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 1000
Test-(0): [100/600]	Time 0.118 (0.147)	Loss 1.305 (1.244)	Prec@1 60.000 (66.119)
Test-(0): [200/600]	Time 0.122 (0.142)	Loss 1.385 (1.246)	Prec@1 52.000 (65.930)
Test-(0): [300/600]	Time 0.135 (0.139)	Loss 1.265 (1.240)	Prec@1 64.000 (66.452)
Test-(0): [400/600]	Time 0.118 (0.138)	Loss 1.165 (1.244)	Prec@1 74.000 (66.125)
Test-(0): [500/600]	Time 0.157 (0.138)	Loss 1.385 (1.242)	Prec@1 52.000 (66.307)
 * Prec@1 66.200 Best_prec1 0.000
============ Testing on the test set ============
Test-(0): [100/1000]	Time 0.120 (0.141)	Loss 1.185 (1.208)	Prec@1 72.000 (69.644)
Test-(0): [200/1000]	Time 0.120 (0.137)	Loss 1.145 (1.225)	Prec@1 76.000 (68.010)
Test-(0): [300/1000]	Time 0.117 (0.135)	Loss 1.105 (1.227)	Prec@1 80.000 (67.761)
Test-(0): [400/1000]	Time 0.141 (0.135)	Loss 1.125 (1.224)	Prec@1 78.000 (68.060)
Test-(0): [500/1000]	Time 0.118 (0.135)	Loss 1.525 (1.222)	Prec@1 38.000 (68.240)
Test-(0): [600/1000]	Time 0.118 (0.136)	Loss 1.225 (1.224)	Prec@1 68.000 (68.087)
Test-(0): [700/1000]	Time 0.118 (0.136)	Loss 1.125 (1.223)	Prec@1 78.000 (68.134)
Test-(0): [800/1000]	Time 0.126 (0.136)	Loss 1.325 (1.225)	Prec@1 58.000 (67.980)
Test-(0): [900/1000]	Time 0.138 (0.136)	Loss 1.105 (1.224)	Prec@1 80.000 (68.129)
 * Prec@1 68.178 Best_prec1 0.000
Namespace(id='', dataset_dir='../dataset/miniImageNet/', data_name='miniImageNet', mode='train', resume='../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar', epochs=0, cuda=True, ngpu=1, nc=3, clamp_lower=-0.01, clamp_upper=0.01, print_freq=100, outf='../results/__miniImageNet_DN4_5_Way_5_Shot_K3')
=> loaded checkpoint '../results/DN4_miniImageNet_Conv64F_5Way_5Shot_K3/model_best.pth.tar' (epoch 16)
DN4(
  (BACKBONE): FourLayer_64F(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (2): LeakyReLU(negative_slope=0.2, inplace=True)
      (3): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (4): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (6): LeakyReLU(negative_slope=0.2, inplace=True)
      (7): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (8): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (9): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (10): LeakyReLU(negative_slope=0.2, inplace=True)
      (11): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (12): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (13): LeakyReLU(negative_slope=0.2, inplace=True)
    )
    (criterion): CrossEntropyLoss()
  )
  (DT): RandomForestHead()
)
============ validation on the val set ============
Trainset: 10000
Valset: 600
Testset: 1000
Test-(0): [100/600]	Time 0.100 (0.125)	Loss 1.205 (1.211)	Prec@1 70.000 (69.366)
Test-(0): [200/600]	Time 0.117 (0.119)	Loss 1.325 (1.217)	Prec@1 58.000 (68.786)
Test-(0): [300/600]	Time 0.120 (0.116)	Loss 1.265 (1.215)	Prec@1 64.000 (68.963)
Test-(0): [400/600]	Time 0.120 (0.116)	Loss 1.265 (1.216)	Prec@1 64.000 (68.878)
Test-(0): [500/600]	Time 0.113 (0.116)	Loss 1.265 (1.219)	Prec@1 64.000 (68.571)
 * Prec@1 68.577 Best_prec1 0.000
============ Testing on the test set ============
Test-(0): [100/1000]	Time 0.110 (0.125)	Loss 1.165 (1.192)	Prec@1 74.000 (71.307)
Test-(0): [200/1000]	Time 0.118 (0.120)	Loss 1.285 (1.191)	Prec@1 62.000 (71.403)
Test-(0): [300/1000]	Time 0.139 (0.118)	Loss 1.265 (1.194)	Prec@1 64.000 (71.103)
Test-(0): [400/1000]	Time 0.112 (0.117)	Loss 1.105 (1.192)	Prec@1 80.000 (71.322)
Test-(0): [500/1000]	Time 0.106 (0.117)	Loss 1.145 (1.191)	Prec@1 76.000 (71.405)
Test-(0): [600/1000]	Time 0.125 (0.117)	Loss 1.165 (1.192)	Prec@1 74.000 (71.281)
Test-(0): [700/1000]	Time 0.112 (0.117)	Loss 1.405 (1.195)	Prec@1 50.000 (70.999)
Test-(0): [800/1000]	Time 0.099 (0.118)	Loss 1.245 (1.195)	Prec@1 66.000 (70.999)
Test-(0): [900/1000]	Time 0.106 (0.118)	Loss 1.265 (1.195)	Prec@1 64.000 (70.946)
 * Prec@1 71.128 Best_prec1 0.000
